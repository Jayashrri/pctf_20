# Pragyan CTF 2020: Auction.


> Find and submit the flag
>
> [./includes/auction](auction)

## Write-up
Given the binary,

1. If we try to run the binary as `./auction`, and experiment with the inputs, we get the output as

```bash
$ ./auction

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 1

 Balance: 1100 

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 1

Cheap Flag: 1000 each
Enter number of flags: 2
Total cost: 2000
Not enough funds

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 1

Cheap Flag: 1000 each
Enter number of flags: 1
Total cost: 1000
New account balance: 100

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 2
Real Flag: 100000  [Only 1 left in stock]
Enter 1 to purchase: 1

Not enough funds

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 3
```

2. Checking the security features of the binary using `checksec auction`,

```bash
$ checksec auction

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

3. If we disassemble the binary with `objdump -D auction`, we get the disassembly of the main function as 

```bash
$ objdump -D auction

0000000000001768 <main>:
    18a5:       c7 45 f4 00 00 00 00    movl   $0x0,-0xc(%rbp)
    18ac:       8b 45 e8                mov    -0x18(%rbp),%eax
    18af:       69 c0 e8 03 00 00       imul   $0x3e8,%eax,%eax
    18b5:       89 45 f4                mov    %eax,-0xc(%rbp)
    18b8:       8b 45 f4                mov    -0xc(%rbp),%eax
    18bb:       89 c6                   mov    %eax,%esi
    18bd:       48 8d 3d 8a 08 00 00    lea    0x88a(%rip),%rdi        # 214e <_IO_stdin_used+0x14e>
    18c4:       b8 00 00 00 00          mov    $0x0,%eax
    18c9:       e8 22 f8 ff ff          callq  10f0 <printf@plt>
    18ce:       8b 45 f4                mov    -0xc(%rbp),%eax
    18d1:       3b 45 f0                cmp    -0x10(%rbp),%eax
    18d4:       7f 21                   jg     18f7 <main+0x18f>
    18d6:       8b 45 f4                mov    -0xc(%rbp),%eax
    18d9:       29 45 f0                sub    %eax,-0x10(%rbp)
    18dc:       8b 45 f0                mov    -0x10(%rbp),%eax
    18df:       89 c6                   mov    %eax,%esi
    18e1:       48 8d 3d 75 08 00 00    lea    0x875(%rip),%rdi        # 215d <_IO_stdin_used+0x15d>
    18e8:       b8 00 00 00 00          mov    $0x0,%eax
    18ed:       e8 fe f7 ff ff          callq  10f0 <printf@plt>
    18f2:       e9 96 00 00 00          jmpq   198d <main+0x225>
    18f7:       48 8d 3d 7a 08 00 00    lea    0x87a(%rip),%rdi        # 2178 <_IO_stdin_used+0x178>
    18fe:       e8 bd f7 ff ff          callq  10c0 <puts@plt>
    1903:       e9 85 00 00 00          jmpq   198d <main+0x225>
    1908:       8b 45 e4                mov    -0x1c(%rbp),%eax
    190b:       83 f8 02                cmp    $0x2,%eax
    190e:       75 7d                   jne    198d <main+0x225>
    1910:       48 8d 3d 79 08 00 00    lea    0x879(%rip),%rdi        # 2190 <_IO_stdin_used+0x190>
    1917:       e8 a4 f7 ff ff          callq  10c0 <puts@plt>
    191c:       48 8d 3d 97 08 00 00    lea    0x897(%rip),%rdi        # 21ba <_IO_stdin_used+0x1ba>
    1923:       b8 00 00 00 00          mov    $0x0,%eax
    1928:       e8 c3 f7 ff ff          callq  10f0 <printf@plt>
    192d:       c7 45 e8 00 00 00 00    movl   $0x0,-0x18(%rbp)
    1934:       48 8b 05 d5 26 00 00    mov    0x26d5(%rip),%rax        # 4010 <stdin@@GLIBC_2.2.5>
    193b:       48 89 c7                mov    %rax,%rdi
    193e:       e8 bd f7 ff ff          callq  1100 <fflush@plt>
    1943:       48 8d 45 e8             lea    -0x18(%rbp),%rax
    1947:       48 89 c6                mov    %rax,%rsi
    194a:       48 8d 3d 75 07 00 00    lea    0x775(%rip),%rdi        # 20c6 <_IO_stdin_used+0xc6>
    1951:       b8 00 00 00 00          mov    $0x0,%eax
    1956:       e8 c5 f7 ff ff          callq  1120 <__isoc99_scanf@plt>
    195b:       8b 45 e8                mov    -0x18(%rbp),%eax
    195e:       83 f8 01                cmp    $0x1,%eax
    1961:       75 2a                   jne    198d <main+0x225>
    1963:       81 7d f0 a0 86 01 00    cmpl   $0x186a0,-0x10(%rbp)
    196a:       7e 0c                   jle    1978 <main+0x210>
    196c:       b8 00 00 00 00          mov    $0x0,%eax
    1971:       e8 cd fa ff ff          callq  1443 <buy_flag>
    1976:       eb 15                   jmp    198d <main+0x225>
```
We see that it performs a `jle` check at `196a` and jumps to a later address if it is true. If the condition is false, then it continues and calls a function called `buy_flag`. This should be the place that checks if the account balance is greater than the needed amount for buying the real flag.

We also see that it performs a `imul` operation at `18af` and a `sub` operation at `18d9` and a `jg` test before that, that shifts the control to a later address if the condition is true. This should be the place that checks if the account balance is sufficient for buying the fake flags.

The amount of money would logically always be a non negative quantity, however the comparisons being made in the program, such as `jle` and `jg` are those for signed integers. Therefore it might be possible to overflow the signed integer variable for amount of money by buying a large amount of fake flags, and so we can gain the amount of money needed to buy a real flag.

4. Testing this out on the binary,

```bash
$ ./auction

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 1

Cheap Flag: 1000 each
Enter number of flags: 999999999 
Total cost: -727380968
New account balance: 727382068

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 2
Real Flag: 100000  [Only 1 left in stock]
Enter 1 to purchase: 1

Enter account password: 
```
We see that this overflow has worked, and now we have sufficient funds to buy the real flag. The program now asks for a password to authenticate the purchase.

5. Looking at the disassembly of the `buy_flag` function in gdb,

```bash
gdbâž¤  disass buy_flag
Dump of assembler code for function buy_flag:
   0x0000000000001443 <+0>:     endbr64 
   0x0000000000001447 <+4>:     push   rbp
   0x0000000000001448 <+5>:     mov    rbp,rsp
   0x000000000000144b <+8>:     sub    rsp,0xd0
   0x0000000000001452 <+15>:    mov    rax,QWORD PTR fs:0x28
   0x000000000000145b <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000000145f <+28>:    xor    eax,eax
   0x0000000000001461 <+30>:    lea    rdi,[rip+0xba0]        # 0x2008
   0x0000000000001468 <+37>:    mov    eax,0x0
   0x000000000000146d <+42>:    call   0x10f0 <printf@plt>
   0x0000000000001472 <+47>:    lea    rax,[rbp-0x82]
   0x0000000000001479 <+54>:    mov    rsi,rax
   0x000000000000147c <+57>:    lea    rdi,[rip+0xba0]        # 0x2023
   0x0000000000001483 <+64>:    mov    eax,0x0
   0x0000000000001488 <+69>:    call   0x1120 <__isoc99_scanf@plt>
   0x000000000000148d <+74>:    movabs rax,0x525d5c41555c5158
   0x0000000000001497 <+84>:    movabs rdx,0x5c5a5a47525b5658
   0x00000000000014a1 <+94>:    mov    QWORD PTR [rbp-0x40],rax
   0x00000000000014a5 <+98>:    mov    QWORD PTR [rbp-0x38],rdx
   0x00000000000014a9 <+102>:   movabs rax,0x525b5844515d505d
   0x00000000000014b3 <+112>:   movabs rdx,0x545259405359545f
   0x00000000000014bd <+122>:   mov    QWORD PTR [rbp-0x30],rax
   0x00000000000014c1 <+126>:   mov    QWORD PTR [rbp-0x28],rdx
   0x00000000000014c5 <+130>:   movabs rax,0x545f5a465255505c
   0x00000000000014cf <+140>:   movabs rdx,0x545e5947555b545b
   0x00000000000014d9 <+150>:   mov    QWORD PTR [rbp-0x20],rax
   0x00000000000014dd <+154>:   mov    QWORD PTR [rbp-0x18],rdx
   0x00000000000014e1 <+158>:   mov    DWORD PTR [rbp-0xcc],0x0
   0x00000000000014eb <+168>:   jmp    0x15c6 <buy_flag+387>
   0x00000000000014f0 <+173>:   mov    DWORD PTR [rbp-0xc8],0x0
   0x00000000000014fa <+183>:   jmp    0x152b <buy_flag+232>
   0x00000000000014fc <+185>:   mov    eax,DWORD PTR [rbp-0xcc]
   0x0000000000001502 <+191>:   lea    edx,[rax*8+0x0]
   0x0000000000001509 <+198>:   mov    eax,DWORD PTR [rbp-0xc8]
   0x000000000000150f <+204>:   add    eax,edx
   0x0000000000001511 <+206>:   cdqe   
   0x0000000000001513 <+208>:   movzx  edx,BYTE PTR [rbp+rax*1-0x40]
   0x0000000000001518 <+213>:   mov    eax,DWORD PTR [rbp-0xc8]
   0x000000000000151e <+219>:   cdqe   
   0x0000000000001520 <+221>:   mov    BYTE PTR [rbp+rax*1-0x79],dl
   0x0000000000001524 <+225>:   add    DWORD PTR [rbp-0xc8],0x1
   0x000000000000152b <+232>:   cmp    DWORD PTR [rbp-0xc8],0x7
   0x0000000000001532 <+239>:   jle    0x14fc <buy_flag+185>
   0x0000000000001534 <+241>:   mov    BYTE PTR [rbp-0x71],0x0
   0x0000000000001538 <+245>:   mov    DWORD PTR [rbp-0xc4],0x0
   0x0000000000001542 <+255>:   jmp    0x1597 <buy_flag+340>
   0x0000000000001544 <+257>:   mov    eax,DWORD PTR [rbp-0xc4]
   0x000000000000154a <+263>:   cdqe   
   0x000000000000154c <+265>:   movzx  edx,BYTE PTR [rbp+rax*1-0x82]
   0x0000000000001554 <+273>:   mov    eax,DWORD PTR [rbp-0xc4]
   0x000000000000155a <+279>:   cdqe   
   0x000000000000155c <+281>:   movzx  eax,BYTE PTR [rbp+rax*1-0x79]
   0x0000000000001561 <+286>:   mov    esi,edx
   0x0000000000001563 <+288>:   xor    esi,eax
   0x0000000000001565 <+290>:   mov    eax,DWORD PTR [rbp-0xc4]
   0x000000000000156b <+296>:   movsxd rcx,eax
   0x000000000000156e <+299>:   mov    eax,DWORD PTR [rbp-0xcc]
   0x0000000000001574 <+305>:   movsxd rdx,eax
   0x0000000000001577 <+308>:   mov    rax,rdx
   0x000000000000157a <+311>:   shl    rax,0x3
   0x000000000000157e <+315>:   add    rax,rdx
   0x0000000000001581 <+318>:   add    rax,rbp
   0x0000000000001584 <+321>:   add    rax,rcx
   0x0000000000001587 <+324>:   sub    rax,0xc0
   0x000000000000158d <+330>:   mov    BYTE PTR [rax],sil
   0x0000000000001590 <+333>:   add    DWORD PTR [rbp-0xc4],0x1
   0x0000000000001597 <+340>:   cmp    DWORD PTR [rbp-0xc4],0x7
   0x000000000000159e <+347>:   jle    0x1544 <buy_flag+257>
   0x00000000000015a0 <+349>:   mov    eax,DWORD PTR [rbp-0xcc]
   0x00000000000015a6 <+355>:   movsxd rdx,eax
   0x00000000000015a9 <+358>:   mov    rax,rdx
   0x00000000000015ac <+361>:   shl    rax,0x3
   0x00000000000015b0 <+365>:   add    rax,rdx
   0x00000000000015b3 <+368>:   add    rax,rbp
   0x00000000000015b6 <+371>:   sub    rax,0xb8
   0x00000000000015bc <+377>:   mov    BYTE PTR [rax],0x0
   0x00000000000015bf <+380>:   add    DWORD PTR [rbp-0xcc],0x1
   0x00000000000015c6 <+387>:   cmp    DWORD PTR [rbp-0xcc],0x5
   0x00000000000015cd <+394>:   jle    0x14f0 <buy_flag+173>
   0x00000000000015d3 <+400>:   lea    rax,[rbp-0xc0]
   0x00000000000015da <+407>:   mov    rdi,rax
   0x00000000000015dd <+410>:   call   0x1229 <checkpass>
   0x00000000000015e2 <+415>:   test   eax,eax
   0x00000000000015e4 <+417>:   je     0x174d <buy_flag+778>
```
The program seems to be setting certain hardcoded hexadecimal strings into the memory, and then performing the xor operation by taking 8 characters at a time with the password taken as input from the user. It then calls a certain function `checkpass` and checks its return value. If the function returns a zero value, then it jumps to a later address.

6. Looking at the disassembly of the `checkpass` function in gdb, 

```bash
gdbâž¤  disas checkpass
Dump of assembler code for function checkpass:
   0x0000000000001229 <+0>:     endbr64 
   0x000000000000122d <+4>:     push   rbp
   0x000000000000122e <+5>:     mov    rbp,rsp
   0x0000000000001231 <+8>:     sub    rsp,0x50
   0x0000000000001235 <+12>:    mov    QWORD PTR [rbp-0x48],rdi
   0x0000000000001239 <+16>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000001242 <+25>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001246 <+29>:    xor    eax,eax
   0x0000000000001248 <+31>:    mov    DWORD PTR [rbp-0x30],0x731
   0x000000000000124f <+38>:    mov    DWORD PTR [rbp-0x2c],0x976
   0x0000000000001256 <+45>:    mov    DWORD PTR [rbp-0x28],0xe72
   0x000000000000125d <+52>:    mov    DWORD PTR [rbp-0x24],0x123d
   0x0000000000001264 <+59>:    mov    DWORD PTR [rbp-0x20],0x103b
   0x000000000000126b <+66>:    mov    DWORD PTR [rbp-0x1c],0xb6d
   0x0000000000001272 <+73>:    mov    DWORD PTR [rbp-0x3c],0x0
   0x0000000000001279 <+80>:    jmp    0x132a <checkpass+257>
   0x000000000000127e <+85>:    mov    DWORD PTR [rbp-0x38],0x0
   0x0000000000001285 <+92>:    jmp    0x12b4 <checkpass+139>
   0x0000000000001287 <+94>:    mov    eax,DWORD PTR [rbp-0x3c]
   0x000000000000128a <+97>:    movsxd rdx,eax
   0x000000000000128d <+100>:   mov    rax,rdx
   0x0000000000001290 <+103>:   shl    rax,0x3
   0x0000000000001294 <+107>:   add    rdx,rax
   0x0000000000001297 <+110>:   mov    rax,QWORD PTR [rbp-0x48]
   0x000000000000129b <+114>:   add    rdx,rax
   0x000000000000129e <+117>:   mov    eax,DWORD PTR [rbp-0x38]
   0x00000000000012a1 <+120>:   cdqe   
   0x00000000000012a3 <+122>:   movzx  edx,BYTE PTR [rdx+rax*1]
   0x00000000000012a7 <+126>:   mov    eax,DWORD PTR [rbp-0x38]
   0x00000000000012aa <+129>:   cdqe   
   0x00000000000012ac <+131>:   mov    BYTE PTR [rbp+rax*1-0x11],dl
   0x00000000000012b0 <+135>:   add    DWORD PTR [rbp-0x38],0x1
   0x00000000000012b4 <+139>:   cmp    DWORD PTR [rbp-0x38],0x7
   0x00000000000012b8 <+143>:   jle    0x1287 <checkpass+94>
   0x00000000000012ba <+145>:   mov    BYTE PTR [rbp-0x9],0x0
   0x00000000000012be <+149>:   mov    eax,DWORD PTR [rbp-0x3c]
   0x00000000000012c1 <+152>:   cdqe   
   0x00000000000012c3 <+154>:   mov    eax,DWORD PTR [rbp+rax*4-0x30]
   0x00000000000012c7 <+158>:   add    eax,0x1
   0x00000000000012ca <+161>:   cvtsi2sd xmm0,eax
   0x00000000000012ce <+165>:   movsd  xmm1,QWORD PTR [rip+0xefa]        # 0x21d0
   0x00000000000012d6 <+173>:   call   0x10d0 <pow@plt>
   0x00000000000012db <+178>:   movsd  QWORD PTR [rbp-0x50],xmm0
   0x00000000000012e0 <+183>:   mov    eax,DWORD PTR [rbp-0x3c]
   0x00000000000012e3 <+186>:   cdqe   
   0x00000000000012e5 <+188>:   mov    eax,DWORD PTR [rbp+rax*4-0x30]
   0x00000000000012e9 <+192>:   cvtsi2sd xmm0,eax
   0x00000000000012ed <+196>:   movsd  xmm1,QWORD PTR [rip+0xedb]        # 0x21d0
   0x00000000000012f5 <+204>:   call   0x10d0 <pow@plt>
   0x00000000000012fa <+209>:   movsd  xmm2,QWORD PTR [rbp-0x50]
   0x00000000000012ff <+214>:   subsd  xmm2,xmm0
   0x0000000000001303 <+218>:   movapd xmm0,xmm2
   0x0000000000001307 <+222>:   cvttsd2si eax,xmm0
   0x000000000000130b <+226>:   mov    DWORD PTR [rbp-0x34],eax
   0x000000000000130e <+229>:   lea    rax,[rbp-0x11]
   0x0000000000001312 <+233>:   mov    rdi,rax
   0x0000000000001315 <+236>:   call   0x1110 <atoi@plt>
   0x000000000000131a <+241>:   cmp    DWORD PTR [rbp-0x34],eax
   0x000000000000131d <+244>:   je     0x1326 <checkpass+253>
   0x000000000000131f <+246>:   mov    eax,0x0
   0x0000000000001324 <+251>:   jmp    0x1339 <checkpass+272>
   0x0000000000001326 <+253>:   add    DWORD PTR [rbp-0x3c],0x1
   0x000000000000132a <+257>:   cmp    DWORD PTR [rbp-0x3c],0x5
   0x000000000000132e <+261>:   jle    0x127e <checkpass+85>
   0x0000000000001334 <+267>:   mov    eax,0x1
   0x0000000000001339 <+272>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x000000000000133d <+276>:   xor    rcx,QWORD PTR fs:0x28
   0x0000000000001346 <+285>:   je     0x134d <checkpass+292>
   0x0000000000001348 <+287>:   call   0x10e0 <__stack_chk_fail@plt>
   0x000000000000134d <+292>:   leave  
   0x000000000000134e <+293>:   ret    
```
There seems to be 6 hardcoded integer values being loaded into an array, and a loop is run 6 times. For each time, the power function is called twice, once with arguments as one added to an array element and a constant value at address `0x21d0`, and another time with arguments as the array element and the constant value. The results of the two power function calls are then subtracted, and is then checked if it is equal to the result of an atoi function.

Checking to see the value at the address `0x21d0` in gdb, it contains the value 3.0. Hence, the function is taking 8 characters of the result of the xor operation, and checking if its integer value is equal to the result calculated from the power function calls.

To get the values that are being checked,
```
0x731 = 1841
(1841+1)^3 - (1841)^3 = 10173367

0x976 = 2242
(2242+1)^3 - (2242)^3 = 15086419

0xe72 = 3698
(3698+1)^3 - (3698)^3 = 41036707

0x123d = 4669
(4669+1)^3 - (4669)^3 = 65412691

0x103b = 4155
(4155+1)^3 - (4155)^3 = 51804541

0xb6d = 2952
(2925+1)^3 - (2925)^3 = 25675651
```

7. To find the password from these values, we perform the xor operation on these values taken as strings with the hardcoded hexadecimal strings taken as little endian seen in the `buy_flag` function
```
(0x58 0x51 0x5c 0x55 0x41 0x5c 0x5d 0x52) ^ ("10173367")
= (0x69 0x61 0x6d 0x62 0x72 0x6f 0x6b 0x65)
= "iambroke"
```

8. Looking at the `buy_flag` function again, 

```bash
gdbâž¤  disass buy_flag
Dump of assembler code for function buy_flag:
   0x00000000000015f6 <+435>:   call   0x10f0 <printf@plt>
   0x00000000000015fb <+440>:   lea    rax,[rbp-0x70]
   0x00000000000015ff <+444>:   mov    rsi,rax
   0x0000000000001602 <+447>:   lea    rdi,[rip+0xa1a]        # 0x2023
   0x0000000000001609 <+454>:   mov    eax,0x0
   0x000000000000160e <+459>:   call   0x1120 <__isoc99_scanf@plt>
   0x0000000000001613 <+464>:   lea    rax,[rbp-0xc0]
   0x000000000000161a <+471>:   mov    rdi,rax
   0x000000000000161d <+474>:   call   0x1110 <atoi@plt>
   0x0000000000001622 <+479>:   mov    edx,eax
   0x0000000000001624 <+481>:   lea    rax,[rbp-0x70]
   0x0000000000001628 <+485>:   mov    esi,0x91
   0x000000000000162d <+490>:   mov    rdi,rax
   0x0000000000001630 <+493>:   call   0x134f <checkotp>
   0x0000000000001635 <+498>:   test   eax,eax
   0x0000000000001637 <+500>:   je     0x1732 <buy_flag+751>
```
We can see that it gets another input from the user, and calls a function `checkotp` multiple times with a different integer value as an argument each time, along with the input string and the result of an atoi function call.

9. Looking at the disassembly of the `checkotp` function,

```bash
gdbâž¤  disas checkotp
Dump of assembler code for function checkotp:
   0x000000000000134f <+0>:     endbr64 
   0x0000000000001353 <+4>:     push   rbp
   0x0000000000001354 <+5>:     mov    rbp,rsp
   0x0000000000001357 <+8>:     sub    rsp,0x40
   0x000000000000135b <+12>:    mov    QWORD PTR [rbp-0x38],rdi
   0x000000000000135f <+16>:    mov    DWORD PTR [rbp-0x3c],esi
   0x0000000000001362 <+19>:    mov    DWORD PTR [rbp-0x40],edx
   0x0000000000001365 <+22>:    mov    rax,QWORD PTR fs:0x28
   0x000000000000136e <+31>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001372 <+35>:    xor    eax,eax
   0x0000000000001374 <+37>:    mov    QWORD PTR [rbp-0x20],0x0
   0x000000000000137c <+45>:    mov    QWORD PTR [rbp-0x18],0x0
   0x0000000000001384 <+53>:    mov    DWORD PTR [rbp-0x28],0x0
   0x000000000000138b <+60>:    jmp    0x140c <checkotp+189>
   0x000000000000138d <+62>:    mov    DWORD PTR [rbp-0x24],0x0
   0x0000000000001394 <+69>:    jmp    0x13be <checkotp+111>
   0x0000000000001396 <+71>:    mov    edx,DWORD PTR [rbp-0x28]
   0x0000000000001399 <+74>:    mov    eax,edx
   0x000000000000139b <+76>:    add    eax,eax
   0x000000000000139d <+78>:    add    edx,eax
   0x000000000000139f <+80>:    mov    eax,DWORD PTR [rbp-0x24]
   0x00000000000013a2 <+83>:    add    eax,edx
   0x00000000000013a4 <+85>:    movsxd rdx,eax
   0x00000000000013a7 <+88>:    mov    rax,QWORD PTR [rbp-0x38]
   0x00000000000013ab <+92>:    add    rax,rdx
   0x00000000000013ae <+95>:    movzx  edx,BYTE PTR [rax]
   0x00000000000013b1 <+98>:    mov    eax,DWORD PTR [rbp-0x24]
   0x00000000000013b4 <+101>:   cdqe   
   0x00000000000013b6 <+103>:   mov    BYTE PTR [rbp+rax*1-0xc],dl
   0x00000000000013ba <+107>:   add    DWORD PTR [rbp-0x24],0x1
   0x00000000000013be <+111>:   cmp    DWORD PTR [rbp-0x24],0x2
   0x00000000000013c2 <+115>:   jle    0x1396 <checkotp+71>
   0x00000000000013c4 <+117>:   mov    BYTE PTR [rbp-0x9],0x0
   0x00000000000013c8 <+121>:   lea    rax,[rbp-0xc]
   0x00000000000013cc <+125>:   mov    rdi,rax
   0x00000000000013cf <+128>:   call   0x1110 <atoi@plt>
   0x00000000000013d4 <+133>:   movsxd rdx,eax
   0x00000000000013d7 <+136>:   mov    rax,QWORD PTR [rbp-0x20]
   0x00000000000013db <+140>:   add    rax,rdx
   0x00000000000013de <+143>:   mov    edx,DWORD PTR [rbp-0x40]
   0x00000000000013e1 <+146>:   movsxd rcx,edx
   0x00000000000013e4 <+149>:   cqo    
   0x00000000000013e6 <+151>:   idiv   rcx
   0x00000000000013e9 <+154>:   mov    QWORD PTR [rbp-0x18],rdx
   0x00000000000013ed <+158>:   cvtsi2sd xmm1,QWORD PTR [rbp-0x18]
   0x00000000000013f3 <+164>:   movsd  xmm0,QWORD PTR [rip+0xddd]        # 0x21d8
   0x00000000000013fb <+172>:   mulsd  xmm0,xmm1
   0x00000000000013ff <+176>:   cvttsd2si rax,xmm0
   0x0000000000001404 <+181>:   mov    QWORD PTR [rbp-0x20],rax
   0x0000000000001408 <+185>:   add    DWORD PTR [rbp-0x28],0x1
   0x000000000000140c <+189>:   cmp    DWORD PTR [rbp-0x28],0xe
   0x0000000000001410 <+193>:   jle    0x138d <checkotp+62>
   0x0000000000001416 <+199>:   mov    eax,DWORD PTR [rbp-0x3c]
   0x0000000000001419 <+202>:   cdqe   
   0x000000000000141b <+204>:   cmp    QWORD PTR [rbp-0x18],rax
   0x000000000000141f <+208>:   jne    0x1428 <checkotp+217>
   0x0000000000001421 <+210>:   mov    eax,0x1
   0x0000000000001426 <+215>:   jmp    0x142d <checkotp+222>
   0x0000000000001428 <+217>:   mov    eax,0x0
   0x000000000000142d <+222>:   mov    rsi,QWORD PTR [rbp-0x8]
   0x0000000000001431 <+226>:   xor    rsi,QWORD PTR fs:0x28
   0x000000000000143a <+235>:   je     0x1441 <checkotp+242>
   0x000000000000143c <+237>:   call   0x10e0 <__stack_chk_fail@plt>
   0x0000000000001441 <+242>:   leave  
   0x0000000000001442 <+243>:   ret    
```
We see that the function takes three arguments. It runs a loop 15 times, where the characters of the otp string are taken three at a time. It then takes the remainder of that string passed to an atoi function when it is divided by the third argument. From the disassembly of the `buy_flag` function, we can see that the first argument is the input string from the user, the second is a hardcoded integer value, and the third is the result of an atoi function called on a string from an address that is being incremented by 9 for every call.

It seems to be that the function `checkotp` is checking if the input string that is gotten as the otp from the user gives the hardcoded integer value as remainder when divided by the integer values of each of the 6 9-character strings we obtained in step 6.

10. Hence to find the otp, it needs to satisfy the following conditions.

```bash
s = 145 mod 10173367
s = 89 mod 15086419
s = 34 mod 41036707
s = 103 mod 65412691
s = 227 mod 51804541
s = 313 mod 25675651
```
We can use the Chinese Remainder Theorem to find the least value that satisfies all the 6 conditions, and hence we get the value of the otp as
```bash
478849720716794761451385564063106643738459224
```

11. Trying out the password and the otp we got in the binary,

```bash
$ ./auction

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 1

Cheap Flag: 1000 each
Enter number of flags: 999999999
Total cost: -727380968
New account balance: 727382068

Welcome to The Flag Auction
1. Check account balance
2. Make a bid
3. Exit
Enter choice: 2

Current Auctions:
1. Cheap Flag
2. Real Flag
Enter your choice: 2
Real Flag: 100000  [Only 1 left in stock]
Enter 1 to purchase: 1

Enter account password: iambroke
Enter OTP: 478849720716794761451385564063106643738459224
p_ctf{The Flag Goes Here}
```

Trying it on the remote link provided,
```bash
p_ctf{17_w45n7_45_51mpl3_4s_1_7h0u9h7}
```
which gives us the flag.